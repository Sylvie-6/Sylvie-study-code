自用整理，大部分内容来源: 爱编程的大丙`subingwen.cn`

`冒泡排序`、`选择排序`、`插入排序`、`希尔排序`、`快速排序`、`归并排序`、`堆排序`、`基数排序`
---
# 冒泡排序
基本思想：重复地遍历要排序的列表，一次比较两个相邻的元素并交换它们的位置来排序列表。\
冒泡排序的时间复杂度取决于输入数组的初始状态：
* 最坏情况下：每次遍历都需要进行比较和交换操作，因此时间复杂度为 `O(n^2)`。
* 最优情况下：如果输入数组已经有序，只需进行一次遍历，时间复杂度为 `O(n)`。
* 平均情况下：每次遍历都需要进行部分比较和交换操作，时间复杂度为 `O(n^2)`。

```cpp
void bubbleSort(vector<int>& vec) {
	int n = vec.size();
	bool swapped = false;
	for (int i = 0; i < n; i++) {
		swapped = false;
		for (int j = 0; j < n - i - 1; j++) {
			if (vec[i] > vec[j]) {
				swap(vec[i], vec[j]);
				swapped = true;
			}
		}
		if (!swapped) {
			break;
		}
	}
}
```

# 选择排序
基本思想：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\
选择排序的时间复杂度不受输入数据的初始状态影响，始终为 `O(n^2)`。具体分析如下：
* 最坏情况下：每次选择最小元素都需要遍历未排序部分的所有元素，因此时间复杂度为 `O(n^2)`。
* 最优情况下：即使输入数据已经有序，选择排序仍需遍历所有元素，因此时间复杂度依旧为 `O(n^2)`。
* 平均情况下：每次选择最小元素的操作与最坏情况类似，时间复杂度为 `O(n^2)`。
```cpp
void selectionSort(vector<int>& vec) {
	int n = vec.size();
	for (int i = 0; i < n; i++) {
		int minPos = i;
		for (int j = i + 1; j < n; j++) {
			if (vec[j] < vec[minPos]) {
				minPos = j;
			}
		}
		if (minPos != i) {
			swap(vec[i], vec[minPos]);
		}
	}
}
```

# 插入排序
基本思想：将未排序部分的元素插入到已排序部分的适当位置，从而逐步构建有序列表。\
插入排序的时间复杂度取决于输入数组的初始状态：
* 最坏情况下：数组是反向排序的，需要进行最大次数的比较和移动操作，时间复杂度为 `O(n^2)`。
* 最优情况下：数组已经有序，只需进行 n-1 次比较，时间复杂度为 `O(n)`。
* 平均情况下：需要进行部分比较和移动操作，时间复杂度为 `O(n^2)`。
```cpp
void insertionSort(vector<int>& vec) {
	int n = vec.size();
	for (int i = 1; i < n; i++) {
		int key = vec[i];
		int j = i - 1;
		while (j >= 0 && vec[j] > key) {
			vec[j + 1] = vec[j];
			j--;
		}
		vec[j + 1] = key;
	}
}
```

# 希尔排序
希尔排序（Shell Sort）是插入排序的一种改进版本，旨在提高插入排序在大规模数据集上的效率。它通过将数据集分割成多个子序列分别进行插入排序，逐步减少子序列的间隔，最终在整个序列上进行插入排序，从而减少数据移动的次数，提升排序效率。\
希尔排序的时间复杂度依赖于间隔序列的选择：
* 最坏情况下：时间复杂度`O(n^2)`。
* 最优情况下：时间复杂度为 `O(n)`。
* 平均情况下：时间复杂 `O(n^1.3)`。
```cpp
void shellSort(vector<int>& vec){
	int n = vec.size();
	for (int gap = n/2; gap > 0; gap /= 2) {
		for (int i = gap; i < n; i++) {
			int j = i - gap;
			int tmp = vec[i];
			while (j >= 0 && vec[j] > tmp) {
				vec[i] = vec[j];
				j -= gap;
			}
			vec[j + gap] = tmp;
		}
	}
}
```

# 快速排序
快速排序采用**分治策略**，通过递归地将数组分割成子数组来实现排序。其平均时间复杂度为 `O(n log n)`\
快速排序的时间复杂度受基准选择的影响：
* 最坏情况下：如果每次选择的基准都是当前数组中的最小或最大值，则每次只能将一个元素放在正确的位置，时间复杂度为 `O(n^2)`。这种情况在数组已经有序或逆序时可能出现。
* 最优情况下：每次选择的基准都能将数组平分，时间复杂度为 `O(n log n)`。
* 平均情况下：在多数情况下，快速排序的时间复杂度为 `O(n log n)`。
```cpp
void quickSort(vector<int>& vec, int left, int right) {
	// 递归结束的条件
	if (left >= right) {
		return;
	}
	int pivot = vec[left + (right - left) / 2];
	int i = left, j = right;

	while (i <= j) {
		while (vec[i] < pivot) i++;
		while (vec[j] > pivot) j--;

		if (i <= j) {
			swap(vec[i], vec[j]);
			i++;
			j--;
		}

		if (left < j) quickSort(vec, left, j);
		if (right > i) quickSort(vec, i, right);
	}
}
```


