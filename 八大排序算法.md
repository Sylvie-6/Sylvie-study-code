自用整理，大部分内容来源: 爱编程的大丙`subingwen.cn`和GPT老师

`冒泡排序`、`选择排序`、`插入排序`、`希尔排序`、`快速排序`、`归并排序`、`堆排序`、`基数排序`

---
# 冒泡排序
基本思想：重复地遍历要排序的列表，一次比较两个相邻的元素并交换它们的位置来排序列表。\
冒泡排序的时间复杂度取决于输入数组的初始状态：
* 最坏情况下：每次遍历都需要进行比较和交换操作，因此时间复杂度为 `O(n^2)`。
* 最优情况下：如果输入数组已经有序，只需进行一次遍历，时间复杂度为 `O(n)`。
* 平均情况下：每次遍历都需要进行部分比较和交换操作，时间复杂度为 `O(n^2)`。

```cpp
void bubbleSort(vector<int>& vec) {
	int n = vec.size();
	bool swapped = false;
	for (int i = 0; i < n; i++) {
		swapped = false;
		for (int j = 0; j < n - i - 1; j++) {
			if (vec[i] > vec[j]) {
				swap(vec[i], vec[j]);
				swapped = true;
			}
		}
		if (!swapped) {
			break;
		}
	}
}
```

# 选择排序
基本思想：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\
选择排序的时间复杂度不受输入数据的初始状态影响，始终为 `O(n^2)`。具体分析如下：
* 最坏情况下：每次选择最小元素都需要遍历未排序部分的所有元素，因此时间复杂度为 `O(n^2)`。
* 最优情况下：即使输入数据已经有序，选择排序仍需遍历所有元素，因此时间复杂度依旧为 `O(n^2)`。
* 平均情况下：每次选择最小元素的操作与最坏情况类似，时间复杂度为 `O(n^2)`。
```cpp
void selectionSort(vector<int>& vec) {
	int n = vec.size();
	for (int i = 0; i < n; i++) {
		int minPos = i;
		for (int j = i + 1; j < n; j++) {
			if (vec[j] < vec[minPos]) {
				minPos = j;
			}
		}
		if (minPos != i) {
			swap(vec[i], vec[minPos]);
		}
	}
}
```

# 插入排序
基本思想：将未排序部分的元素插入到已排序部分的适当位置，从而逐步构建有序列表。\
插入排序的时间复杂度取决于输入数组的初始状态：
* 最坏情况下：数组是反向排序的，需要进行最大次数的比较和移动操作，时间复杂度为 `O(n^2)`。
* 最优情况下：数组已经有序，只需进行 n-1 次比较，时间复杂度为 `O(n)`。
* 平均情况下：需要进行部分比较和移动操作，时间复杂度为 `O(n^2)`。
```cpp
void insertionSort(vector<int>& vec) {
	int n = vec.size();
	for (int i = 1; i < n; i++) {
		int key = vec[i];
		int j = i - 1;
		while (j >= 0 && vec[j] > key) {
			vec[j + 1] = vec[j];
			j--;
		}
		vec[j + 1] = key;
	}
}
```

# 希尔排序
希尔排序（Shell Sort）是插入排序的一种改进版本，旨在提高插入排序在大规模数据集上的效率。它通过将数据集分割成多个子序列分别进行插入排序，逐步减少子序列的间隔，最终在整个序列上进行插入排序，从而减少数据移动的次数，提升排序效率。\
希尔排序的时间复杂度依赖于间隔序列的选择：
* 最坏情况下：时间复杂度`O(n^2)`。
* 最优情况下：时间复杂度为 `O(n)`。
* 平均情况下：时间复杂 `O(n^1.3)`。
```cpp
void shellSort(vector<int>& vec){
	int n = vec.size();
	for (int gap = n/2; gap > 0; gap /= 2) {
		for (int i = gap; i < n; i++) {
			int j = i - gap;
			int tmp = vec[i];
			while (j >= 0 && vec[j] > tmp) {
				vec[i] = vec[j];
				j -= gap;
			}
			vec[j + gap] = tmp;
		}
	}
}
```

# 快速排序
“选择基准，分区操作”\
快速排序采用**分治策略**，通过递归地将数组分割成子数组来实现排序。其平均时间复杂度为 `O(n log n)`\
快速排序的时间复杂度受基准选择的影响：
* 最坏情况下：如果每次选择的基准都是当前数组中的最小或最大值，则每次只能将一个元素放在正确的位置，时间复杂度为 `O(n^2)`。这种情况在数组已经有序或逆序时可能出现。
* 最优情况下：每次选择的基准都能将数组平分，时间复杂度为 `O(n log n)`。
* 平均情况下：在多数情况下，快速排序的时间复杂度为 `O(n log n)`。
```cpp
void quickSort(vector<int>& vec, int left, int right) {
	// 递归结束的条件
	if (left >= right) {
		return;
	}
	// 选择基准
	int pivot = vec[left + (right - left) / 2];
	// 双指针从两端向中间逼近
	int i = left, j = right;

	// 核心分区循环：把 <pivot 的放到左边，>pivot 的放到右边
	while (i <= j) {
		// 从左往右找：停在第一个 >= pivot 的元素
		while (vec[i] < pivot) i++;
		// 从右往左找：停在第一个 <= pivot 的元素
		while (vec[j] > pivot) j--;

		// 左指针没有越过右指针：两边各有一个需要交换的位置
		if (i <= j) {
			swap(vec[i], vec[j]);
			i++;
			j--;
		}

		if (left < j) quickSort(vec, left, j);
		if (right > i) quickSort(vec, i, right);
	}
}
```

# 归并排序
基本思想：将数组分成两个子数组，分别进行排序，然后合并这两个有序子数组。\
归并排序的时间复杂度可以通过递归方程来分析：
* 最坏情况下：归并排序的时间复杂度为 `O(n log n)`，因为每次分割数组的操作都是对半分，递归深度为 `log n`，每层的合并操作时间复杂度为 `O(n)`。
* 最优情况下：时间复杂度同样为 `O(n log n)`，因为归并排序的过程与数组的初始顺序无关，始终需要进行分割和合并操作。
* 平均情况下：归并排序的时间复杂度也是 `O(n log n)`，因为它在任何情况下都需要进行相同数量的分割和合并操作。
```cpp
void mergeSort(vector<int>& vec, int left, int right) {
	if (left >= right) {
		return;
	}
	int mid = left + (right - left) / 2;

	mergeSort(vec, left, mid);
	mergeSort(vec, mid + 1, right);

	int k = 0;
	int i = left, j = mid + 1;
	vector<int> tmp;
	// 把两个有序子数组合并到 temp
	while (i <= mid && j <= right) {

		if (vec[i] <= vec[j]) {
			tmp.push_back(vec[i]);
			i++;
		}
		else {
			tmp.push_back(vec[j]);
			j++;
		}
	}
	while (i <= mid) {
		tmp.push_back(vec[i]);
		i++;
	}
	while (j <= right) {
		tmp.push_back(vec[j]);
		j++;
	}
	//把 tmp 中的合并结果写回到原数组的 [left, right] 区间
	for (int i = left; i <= right; i++) {
		vec[i] = tmp[k];
		k++;
	}
}
```

# 堆排序
堆排序（Heap Sort）是一种基于二叉堆数据结构的比较排序算法。堆排序利用堆这种数据结构的性质来实现排序，分为构建初始堆和反复从堆中取出最大元素（对于升序排序）两个主要步骤。堆排序的时间复杂度为 `O(n log n)`，且不需要额外的内存空间。\
#### 最大堆（Max Heap）
对于每个节点 i，其父节点 parent(i) 的值都不小于节点 i 的值。换句话说，堆中任意节点的值都大于或等于其子节点的值。
#### 最小堆（Min Heap）
对于每个节点 i，其父节点 parent(i) 的值都不大于节点 i 的值。也就是说，堆中任意节点的值都小于或等于其子节点的值。

堆的底层实现是完全二叉树，对于包含 n 个节点的完全二叉树，节点的索引（从 0 开始）与父子关系有固定规律, 对于任意节点 i：
* 左孩子索引 = 2*i + 1
* 右孩子索引 = 2*i + 2
* 父节点索引 = (i - 1) / 2（整数除法）

堆排序的核心思路
* 大根堆版（升序排序）
  * 先把数组调整成大根堆，最大元素在堆顶。
  * 把堆顶（最大值）和最后一个元素交换，堆大小减一。
  * 重新调整堆，让新的堆顶仍然是最大值。
  * 重复，直到整个数组有序。
* 小根堆版（降序排序）
  * 思路类似，只不过堆顶是最小值，每次取走最小的，最终得到降序排列。
```cpp
// 大根堆—————升序
void heapify(vector<int>& vec, int n, int i) {
	// n:数组长度 i:父节点
	int largest = i;
	int l = 2 * i + 1;
	int r = 2 * i + 2;

	if (l<n && vec[l]>vec[largest]) largest = l;
	if (r<n && vec[r]>vec[largest]) largest = r;

	if (largest != i) {
		swap(vec[i], vec[largest]);
		heapify(vec, n, largest);
	}
}

void heapSort(vector<int>& vec) {
	int n = vec.size();
	// 1. 建大根堆
	for (int i = n / 2 - 1; i >= 0; i--) {
		heapify(vec, n, i);
	}
	// 2. 依次把堆顶（最大值）交换到末尾
	for (int j = n - 1; j > 0; j--) {
		swap(vec[0], vec[j]);// 堆顶放到已排序区
		heapify(vec, j, 0);// 调整剩下的部分
	}
}
```
```cpp
// 小根堆—————降序
void heapifyMin(vector<int>& vec, int n, int i) {
	int smallest = i;
	int l = 2 * i + 1;
	int r = 2 * i + 2;

	if (l < n && vec[l] < vec[smallest]) smallest = l;
	if (r < n && vec[r] < vec[smallest]) smallest = r;

	if (smallest != i) {
		swap(vec[i], vec[smallest]);
		heapifyMin(vec, n, smallest);
	}
}

void heapSortDesc(vector<int>& vec) {
	int n = vec.size();

	for (int i = n / 2 - 1; i >= 0; i--) {
		heapifyMin(vec, n, i);

		for (int j = n - 1; j > 0; j--) {
			swap(vec[0], vec[j]);
			heapifyMin(vec, j, 0);
		}
	}
}
```

# 基数排序
基数排序（Radix Sort）是一种非比较排序算法，通过逐位处理数字来排序数组。它利用桶排序的思想，**对数字的每一位进行排序，从最低有效位到最高有效位**。基数排序特别适用于处理大量的整数或字符串数据。其时间复杂度为 `O(d*(n+k))`，其中 `d` 是数字的位数，`n` 是数组的长度，`k` 是基数【使用十进制，基数 `( k = 10 )`】
```cpp
void radixSort(vector<int>& vec)
{
    int max = 0;
    for (int i = 0; i < vec.size(); ++i)
    {
        if (max < vec[i])
        {
            max = vec[i];
        }
    }
    int len = to_string(max).length();

    vector<vector<int>> bucket;
    int mod = 10, dev = 1;
    for (int i = 0; i < len; ++i, mod *= 10, dev *= 10)
    {
        bucket.resize(10);  // 有10个桶: 0~9
        for (int j = 0; j < vec.size(); ++j)
        {
            int num = vec[j] % mod / dev;
            bucket[num].push_back(vec[j]);
        }
        int index = 0;
        for (const auto& item : bucket)
        {
            for (const auto& it : item)
            {
                vec[index++] = it;
            }
        }
        bucket.clear();
    }
}
```
