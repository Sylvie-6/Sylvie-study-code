C++11 引入智能指针的核心目的是解决裸指针的内存管理问题：传统裸指针需要手动delete释放内存，容易出现 “内存泄漏”（忘记释放）、“二次释放”（重复释放）、“悬垂指针”（指向已释放的内存）等问题。

智能指针基于RAII（资源获取即初始化） 机制，在对象生命周期结束时（离开作用域）自动释放内存，无需手动管理，大幅减少内存安全问题。

## 三种智能指针：
### std::unique_ptr
对所管理的资源拥有唯一所有权，不允许复制（copy），只能通过移动（move）转移所有权。（底层禁用了拷贝构造和赋值运算符，只保留移动构造和移动赋值）\
适合单所有者场景，比如临时对象或函数返回值。优点：轻量、高效，性能接近原生指针。\
示例：
```cpp
auto ptr = std::make_unique<int>(42);
```

### std::shared_ptr
允许多个shared_ptr共享同一资源的所有权(多个指针可以指向同一个对象)，通过引用计数（reference count）跟踪所有者数量：
   * 每次复制shared_ptr（如赋值、传参），引用计数 + 1；
   * 每次shared_ptr销毁（离开作用域），引用计数 - 1；
   * 当引用计数为 0 时，自动释放资源。
适合需要多个对象共享同一资源的场景。注意：有性能开销（引用计数），可能产生循环引用。\
示例：
```cpp
auto ptr1 = std::make_shared<int>(100);
auto ptr2 = ptr1; // 引用计数+1
```

### std::weak_ptr
用于解决 shared_ptr 的循环引用问题。不增加引用计数，只能观察 shared_ptr 管理的对象。使用前需调用 lock() 转为 shared_ptr，避免访问已释放的内存。\
示例：
```cpp
std::weak_ptr<int> weak = ptr1;
if (auto shared = weak.lock()) {
    // 安全使用
}
```

## 智能指针用法演示
场景：模拟一个“图书管理系统”\
我们有：
* 书籍（Book）
* 图书馆（Library）——管理书籍
* 读者（Reader）——可以借书

要求：
* 一本书只能被一个图书馆拥有（用 unique_ptr）
* 读者可以借阅同一本书（多个读者共享一本书，用 shared_ptr）
* 读者不能持有对书的强引用（避免循环引用），用 weak_ptr 表示“借阅关系”

---

```cpp
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <map>

// 书籍类
class Book {
public:
    std::string title;
    std::string author;

    Book(const std::string& t, const std::string& a) : title(t), author(a) {
        std::cout << "📖 书籍《" << title << "》被创建了！\n";
    }

    ~Book() {
        std::cout << "🗑️ 书籍《" << title << "》被销毁了。\n";
    }

    void read() const {
        std::cout << "📖 正在阅读《" << title << "》 by " << author << "\n";
    }
};

// 读者类：持有对书的 weak_ptr（借阅关系）
class Reader {
private:
    std::string name;
    std::weak_ptr<Book> borrowed_book; // 不拥有，只是观察

public:
    Reader(const std::string& n) : name(n) {}

    void borrow(std::shared_ptr<Book> book) {
        borrowed_book = book;
        std::cout << "👤 读者 " << name << " 借阅了《" << book->title << "》\n";
    }

    void read() {
        if (auto book = borrowed_book.lock()) { // 检查是否还有效
            book->read();
        } else {
            std::cout << "❌ 读者 " << name << " 想读的书已归还或被销毁。\n";
        }
    }
};

// 图书馆类：拥有书籍的所有权（用 unique_ptr）
class Library {
private:
    std::string name;
    std::vector<std::unique_ptr<Book>> books; // 专属拥有

public:
    Library(const std::string& n) : name(n) {}

    // 添加一本书（图书馆独占所有权）
    void addBook(std::unique_ptr<Book> book) {
        books.push_back(std::move(book));
        std::cout << "📚 图书馆 " << name << " 新增书籍：《" << books.back()->title << "》\n";
    }

    // 为读者提供共享的书（shared_ptr）
    std::shared_ptr<Book> getBook(const std::string& title) {
        for (auto& book : books) {
            if (book->title == title) {
                // 返回 shared_ptr，让读者可以共享
                return std::shared_ptr<Book>(book.get()); // 注意：这里只传递裸指针，但会共享引用计数
            }
        }
        std::cout << "❌ 图书馆 " << name << " 没有找到《" << title << "》\n";
        return nullptr;
    }

    // 释放所有书（自动销毁）
    ~Library() {
        std::cout << "🏛️ 图书馆 " << name << " 关闭，所有书籍已归还。\n";
    }
};

// 主函数：演示三者协作
int main() {
    // 1. 创建图书馆，用 unique_ptr 管理书籍
    auto library = std::make_unique<Library>("市立图书馆");

    // 2. 添加几本书（unique_ptr 管理）
    library->addBook(std::make_unique<Book>("C++ Primer", "Stanley Lippman"));
    library->addBook(std::make_unique<Book>("Effective C++", "Scott Meyers"));

    // 3. 创建读者
    auto reader1 = std::make_shared<Reader>("小明");
    auto reader2 = std::make_shared<Reader>("小红");

    // 4. 读者借书（通过 shared_ptr 共享）
    auto book1 = library->getBook("C++ Primer");
    if (book1) {
        reader1->borrow(book1); // 小明借书
        reader2->borrow(book1); // 小红也借同一本书
    }

    // 5. 读者阅读
    reader1->read(); // ✅ 正常读
    reader2->read(); // ✅ 正常读

    // 6. 图书馆被销毁（unique_ptr 释放）
    // 这会触发 books 的销毁，但因为 book1 是 shared_ptr，所以书不会被立即销毁
    // 只有当所有 shared_ptr 和 weak_ptr 都释放后，书才真正销毁

    // 7. 释放读者（但书还在，因为 shared_ptr 还在）
    reader1.reset();
    reader2.reset();

    // 8. 再次尝试读（此时书可能已被释放）
    std::cout << "\n➡️ 读者已释放，尝试再次阅读...\n";
    reader1 = std::make_shared<Reader>("小明");
    reader1->read(); // ❌ 书已销毁，weak_ptr 无法获取

    return 0;
}
```

#### 输出结果：
```
📖 书籍《C++ Primer》被创建了！
📖 书籍《Effective C++》被创建了！
📚 图书馆 市立图书馆 新增书籍：《C++ Primer》
📚 图书馆 市立图书馆 新增书籍：《Effective C++》
👤 读者 小明 借阅了《C++ Primer》
👤 读者 小红 借阅了《C++ Primer》
📖 正在阅读《C++ Primer》 by Stanley Lippman
📖 正在阅读《C++ Primer》 by Stanley Lippman

🏛️ 图书馆 市立图书馆 关闭，所有书籍已归还。

🗑️ 书籍《C++ Primer》被销毁了。
🗑️ 书籍《Effective C++》被销毁了。

➡️ 读者已释放，尝试再次阅读...
❌ 读者 小明 想读的书已归还或被销毁。
```
---

### 三者用法总结

| 智能指针 | 用法 | 作用 | 何时用 |
|--------|------|------|--------|
| `std::unique_ptr` | `std::make_unique<Book>(...)`<br>`library->addBook(std::move(book))` | **独占所有权**，自动销毁 | 管理单个对象，如容器、临时资源 |
| `std::shared_ptr` | `std::make_shared<Book>(...)`<br>`library->getBook(...)` | **共享所有权**，引用计数 | 多个对象需要共享同一资源 |
| `std::weak_ptr` | `std::weak_ptr<Book> borrowed_book;`<br>`if (auto book = weak.lock())` | **观察共享对象**，不增加引用计数 | 避免循环引用，表示“借阅”“观察”关系 |

### 关键点：
- `shared_ptr` 的引用计数是线程安全的，但操作有开销。
- `weak_ptr` 只能通过 `lock()` 转为 `shared_ptr`，否则不能访问。
- `unique_ptr` 不能复制，只能移动，性能最好。
- **不要用 `shared_ptr` 管理 `unique_ptr` 管理的对象**，否则会重复释放！
---
## 手撕智能指针
### `std::unique_ptr`
```cpp
template <typename T>
class unique_ptr {
private:
    T* ptr;

public:
    // 构造函数
    explicit unique_ptr(T* p = nullptr) : ptr(p) {}

    // 移动构造函数
    unique_ptr(unique_ptr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }

    // 移动赋值操作符
    unique_ptr& operator=(unique_ptr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }

    // 禁止拷贝
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    // 解引用
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    // 获取原始指针
    T* get() const { return ptr; }

    // 释放资源
    ~unique_ptr() {
        delete ptr;
    }
};
```
* 必须禁用拷贝（delete）
* 移动语义必须 noexcept
* 析构函数会 delete 指针
* 可以用 get() 获取裸指针（用于传递给其他函数）
### `std::shared_ptr`
```cpp
template <typename T>
class shared_ptr {
private:
    T* ptr;
    size_t* ref_count;

public:
    // 构造函数
    explicit shared_ptr(T* p = nullptr) : ptr(p), ref_count(new size_t(1)) {}

    // 拷贝构造
    shared_ptr(const shared_ptr& other) : ptr(other.ptr), ref_count(other.ref_count) {
        ++(*ref_count);
    }

    // 拷贝赋值
    shared_ptr& operator=(const shared_ptr& other) {
        if (this != &other) {
            // 释放当前资源
            if (ptr && --(*ref_count) == 0) {
                delete ptr;
                delete ref_count;
            }

            // 赋值新资源
            ptr = other.ptr;
            ref_count = other.ref_count;
            ++(*ref_count);
        }
        return *this;
    }

    // 移动构造
    shared_ptr(shared_ptr&& other) noexcept
        : ptr(other.ptr), ref_count(other.ref_count) {
        other.ptr = nullptr;
        other.ref_count = nullptr;
    }

    // 移动赋值
    shared_ptr& operator=(shared_ptr&& other) noexcept {
        if (this != &other) {
            if (ptr && --(*ref_count) == 0) {
                delete ptr;
                delete ref_count;
            }
            ptr = other.ptr;
            ref_count = other.ref_count;
            other.ptr = nullptr;
            other.ref_count = nullptr;
        }
        return *this;
    }

    // 解引用
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    // 获取引用计数
    size_t use_count() const { return *ref_count; }

    // 获取裸指针
    T* get() const { return ptr; }

    // 析构
    ~shared_ptr() {
        if (ptr && --(*ref_count) == 0) {
            delete ptr;
            delete ref_count;
        }
    }
};
```
* 引用计数用 size_t* 管理，支持共享
* 所有操作都要判断 this != &other
* 拷贝时 ++ref_count
* 析构时 --ref_count，为 0 时才释放资源
* 可以加 use_count() 展示智能性
### `std::weak_ptr`
```cpp
template <typename T>
class weak_ptr {
private:
    T* ptr;
    size_t* ref_count;

public:
    // 构造函数（从 shared_ptr 构造）
    template <typename U>
    weak_ptr(const shared_ptr<U>& other) noexcept
        : ptr(other.get()), ref_count(other.ref_count) {}

    // 拷贝构造
    weak_ptr(const weak_ptr& other) noexcept
        : ptr(other.ptr), ref_count(other.ref_count) {}

    // 拷贝赋值
    weak_ptr& operator=(const weak_ptr& other) noexcept {
        ptr = other.ptr;
        ref_count = other.ref_count;
        return *this;
    }

    // 移动操作（可选）
    weak_ptr(weak_ptr&& other) noexcept
        : ptr(other.ptr), ref_count(other.ref_count) {
        other.ptr = nullptr;
        other.ref_count = nullptr;
    }

    // 赋值
    weak_ptr& operator=(weak_ptr&& other) noexcept {
        ptr = other.ptr;
        ref_count = other.ref_count;
        other.ptr = nullptr;
        other.ref_count = nullptr;
        return *this;
    }

    // lock()：尝试获取 shared_ptr，若资源已释放则返回空
    std::shared_ptr<T> lock() const {
        if (ref_count && *ref_count > 0) {
            return std::shared_ptr<T>(ptr, ref_count);
        }
        return std::shared_ptr<T>();
    }

    // 检查是否还有效
    bool expired() const {
        return !ptr || *ref_count == 0;
    }

    // 获取引用计数（仅调试用）
    size_t use_count() const {
        return ref_count ? *ref_count : 0;
    }

    // 析构
    ~weak_ptr() = default; // 不释放资源
};
```
* lock() 是核心：检查是否还活着，活着就返回 shared_ptr
* expired() 判断资源是否已释放
* 不增加引用计数，只观察
* 用 shared_ptr 构造，不能从裸指针构造
