C++的智能指针是现代C++中非常重要的特性，主要用于自动管理动态内存，避免内存泄漏和悬空指针等问题。

## 三种智能指针：
### std::unique_ptr
独占所有权，不允许复制，但可以移动。适合单所有者场景，比如临时对象或函数返回值。优点：轻量、高效，性能接近原生指针。\
示例：
```cpp
auto ptr = std::make_unique<int>(42);
```

### std::shared_ptr
共享所有权，通过引用计数实现。多个指针可以指向同一个对象，当最后一个 shared_ptr 被销毁时，自动释放资源。
适合需要多个对象共享同一资源的场景。注意：有性能开销（引用计数），可能产生循环引用。\
示例：
```cpp
auto ptr1 = std::make_shared<int>(100);
auto ptr2 = ptr1; // 引用计数+1
```

### std::weak_ptr
用于解决 shared_ptr 的循环引用问题。不增加引用计数，只能观察 shared_ptr 管理的对象。使用前需调用 lock() 转为 shared_ptr，避免访问已释放的内存。\
示例：
```cpp
std::weak_ptr<int> weak = ptr1;
if (auto shared = weak.lock()) {
    // 安全使用
}
```

## 智能指针用法演示
场景：模拟一个“图书管理系统”\
我们有：
* 书籍（Book）
* 图书馆（Library）——管理书籍
* 读者（Reader）——可以借书
要求：\
* 一本书只能被一个图书馆拥有（用 unique_ptr）
* 读者可以借阅同一本书（多个读者共享一本书，用 shared_ptr）
* 读者不能持有对书的强引用（避免循环引用），用 weak_ptr 表示“借阅关系”

---

```cpp
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <map>

// 书籍类
class Book {
public:
    std::string title;
    std::string author;

    Book(const std::string& t, const std::string& a) : title(t), author(a) {
        std::cout << "📖 书籍《" << title << "》被创建了！\n";
    }

    ~Book() {
        std::cout << "🗑️ 书籍《" << title << "》被销毁了。\n";
    }

    void read() const {
        std::cout << "📖 正在阅读《" << title << "》 by " << author << "\n";
    }
};

// 读者类：持有对书的 weak_ptr（借阅关系）
class Reader {
private:
    std::string name;
    std::weak_ptr<Book> borrowed_book; // 不拥有，只是观察

public:
    Reader(const std::string& n) : name(n) {}

    void borrow(std::shared_ptr<Book> book) {
        borrowed_book = book;
        std::cout << "👤 读者 " << name << " 借阅了《" << book->title << "》\n";
    }

    void read() {
        if (auto book = borrowed_book.lock()) { // 检查是否还有效
            book->read();
        } else {
            std::cout << "❌ 读者 " << name << " 想读的书已归还或被销毁。\n";
        }
    }
};

// 图书馆类：拥有书籍的所有权（用 unique_ptr）
class Library {
private:
    std::string name;
    std::vector<std::unique_ptr<Book>> books; // 专属拥有

public:
    Library(const std::string& n) : name(n) {}

    // 添加一本书（图书馆独占所有权）
    void addBook(std::unique_ptr<Book> book) {
        books.push_back(std::move(book));
        std::cout << "📚 图书馆 " << name << " 新增书籍：《" << books.back()->title << "》\n";
    }

    // 为读者提供共享的书（shared_ptr）
    std::shared_ptr<Book> getBook(const std::string& title) {
        for (auto& book : books) {
            if (book->title == title) {
                // 返回 shared_ptr，让读者可以共享
                return std::shared_ptr<Book>(book.get()); // 注意：这里只传递裸指针，但会共享引用计数
            }
        }
        std::cout << "❌ 图书馆 " << name << " 没有找到《" << title << "》\n";
        return nullptr;
    }

    // 释放所有书（自动销毁）
    ~Library() {
        std::cout << "🏛️ 图书馆 " << name << " 关闭，所有书籍已归还。\n";
    }
};

// 主函数：演示三者协作
int main() {
    // 1. 创建图书馆，用 unique_ptr 管理书籍
    auto library = std::make_unique<Library>("市立图书馆");

    // 2. 添加几本书（unique_ptr 管理）
    library->addBook(std::make_unique<Book>("C++ Primer", "Stanley Lippman"));
    library->addBook(std::make_unique<Book>("Effective C++", "Scott Meyers"));

    // 3. 创建读者
    auto reader1 = std::make_shared<Reader>("小明");
    auto reader2 = std::make_shared<Reader>("小红");

    // 4. 读者借书（通过 shared_ptr 共享）
    auto book1 = library->getBook("C++ Primer");
    if (book1) {
        reader1->borrow(book1); // 小明借书
        reader2->borrow(book1); // 小红也借同一本书
    }

    // 5. 读者阅读
    reader1->read(); // ✅ 正常读
    reader2->read(); // ✅ 正常读

    // 6. 图书馆被销毁（unique_ptr 释放）
    // 这会触发 books 的销毁，但因为 book1 是 shared_ptr，所以书不会被立即销毁
    // 只有当所有 shared_ptr 和 weak_ptr 都释放后，书才真正销毁

    // 7. 释放读者（但书还在，因为 shared_ptr 还在）
    reader1.reset();
    reader2.reset();

    // 8. 再次尝试读（此时书可能已被释放）
    std::cout << "\n➡️ 读者已释放，尝试再次阅读...\n";
    reader1 = std::make_shared<Reader>("小明");
    reader1->read(); // ❌ 书已销毁，weak_ptr 无法获取

    return 0;
}
```

#### 输出结果：
```
📖 书籍《C++ Primer》被创建了！
📖 书籍《Effective C++》被创建了！
📚 图书馆 市立图书馆 新增书籍：《C++ Primer》
📚 图书馆 市立图书馆 新增书籍：《Effective C++》
👤 读者 小明 借阅了《C++ Primer》
👤 读者 小红 借阅了《C++ Primer》
📖 正在阅读《C++ Primer》 by Stanley Lippman
📖 正在阅读《C++ Primer》 by Stanley Lippman

🏛️ 图书馆 市立图书馆 关闭，所有书籍已归还。

🗑️ 书籍《C++ Primer》被销毁了。
🗑️ 书籍《Effective C++》被销毁了。

➡️ 读者已释放，尝试再次阅读...
❌ 读者 小明 想读的书已归还或被销毁。
```
---

### 三者用法总结

| 智能指针 | 用法 | 作用 | 何时用 |
|--------|------|------|--------|
| `std::unique_ptr` | `std::make_unique<Book>(...)`<br>`library->addBook(std::move(book))` | **独占所有权**，自动销毁 | 管理单个对象，如容器、临时资源 |
| `std::shared_ptr` | `std::make_shared<Book>(...)`<br>`library->getBook(...)` | **共享所有权**，引用计数 | 多个对象需要共享同一资源 |
| `std::weak_ptr` | `std::weak_ptr<Book> borrowed_book;`<br>`if (auto book = weak.lock())` | **观察共享对象**，不增加引用计数 | 避免循环引用，表示“借阅”“观察”关系 |

### 关键点提醒：
- `shared_ptr` 的引用计数是线程安全的，但操作有开销。
- `weak_ptr` 只能通过 `lock()` 转为 `shared_ptr`，否则不能访问。
- `unique_ptr` 不能复制，只能移动，性能最好。
- **不要用 `shared_ptr` 管理 `unique_ptr` 管理的对象**，否则会重复释放！

